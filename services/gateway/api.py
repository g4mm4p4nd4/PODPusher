from contextlib import asynccontextmanager
from datetime import datetime
from typing import List
from fastapi import Depends, FastAPI, HTTPException
from ..trend_scraper.service import (
    fetch_trends,
    get_trending_categories,
    get_design_ideas,
    get_product_suggestions,
)
from ..ideation.service import generate_ideas
from ..ideation.api import app as ideation_app
from ..image_gen.service import generate_images
from ..integration.service import create_sku, publish_listing, load_oauth_credentials
from ..common.auth import require_user_id
from ..models import OAuthProvider
from ..product.api import app as product_app
from ..notifications.api import app as notifications_app
from ..search.api import app as search_app
from ..ab_tests.api import app as ab_app
from ..listing_composer.api import app as listing_app
from ..social_generator.api import app as social_app
from ..auth.api import app as auth_app
from ..common.observability import register_observability
from ..bulk_create.api import BulkCreateResponse, bulk_create as bulk_create_handler
from fastapi import Request
from ..trend_scraper.events import EVENTS
from ..analytics.middleware import AnalyticsMiddleware
from ..trend_ingestion.service import (
    get_live_trends,
    refresh_trends,
    start_scheduler,
)

@asynccontextmanager
def _gateway_lifespan(app: FastAPI):
    start_scheduler()
    yield

app = FastAPI(lifespan=_gateway_lifespan)
register_observability(app, service_name="gateway")
app.mount("/api/products", product_app)
app.mount("/api/notifications", notifications_app)
app.mount("/api/search", search_app)
app.mount("/ab_tests", ab_app)
app.mount("/api/ideation", ideation_app)
app.mount("/api/listing-composer", listing_app)
app.mount("/api/social", social_app)
app.mount("/api/auth", auth_app)
app.add_middleware(AnalyticsMiddleware)

def _assemble_products(ideas: List[dict], images: List[dict]) -> List[dict]:
    idea_lookup = {idea.get("id"): idea for idea in ideas if idea.get("id") is not None}
    products: List[dict] = []
    for image in images:
        idea_id = image.get("idea_id")
        idea = idea_lookup.get(idea_id)
        if not idea:
            continue
        base_tags = [idea.get("term"), idea.get("category"), image.get("category")]
        tags = [tag for tag in {tag for tag in base_tags if tag}]
        products.append(
            {
                "id": image.get("id"),
                "idea_id": idea_id,
                "title": (idea.get("description") or idea.get("term", "Design")).strip()[:120]
                or "Automated POD Listing",
                "description": idea.get("description") or "Generated by POD Automator",
                "image_url": image.get("image_url"),
                "category": image.get("category") or idea.get("category"),
                "tags": tags,
                "price": idea.get("suggested_price") or 24.99,
            }
        )
    return products

@app.post("/generate")
async def generate(
    category: str | None = None,
    user_id: int = Depends(require_user_id),
):
    trends = await fetch_trends(category)
    if not trends:
        raise HTTPException(status_code=503, detail="No trends available")
    ideas = await generate_ideas(trends)
    if not ideas:
        raise HTTPException(status_code=503, detail="Failed to generate ideas")
    images = await generate_images(ideas)
    if not images:
        raise HTTPException(status_code=503, detail="Failed to generate product images")
    product_inputs = _assemble_products(ideas, images)
    if not product_inputs:
        raise HTTPException(status_code=503, detail="Unable to build product payloads")

    printify_credentials = await load_oauth_credentials(user_id, OAuthProvider.PRINTIFY)
    products = create_sku(product_inputs, credential=printify_credentials)
    if not products:
        raise HTTPException(status_code=502, detail="Printify did not return any products")

    etsy_credentials = await load_oauth_credentials(user_id, OAuthProvider.ETSY)
    listing = publish_listing(dict(products[0]), credential=etsy_credentials)
    if not listing:
        raise HTTPException(status_code=502, detail="Unable to publish listing")

    month = datetime.utcnow().strftime("%B").lower()
    events = EVENTS.get(month, [])
    listing_url = listing.get("etsy_url")
    listing["listing_url"] = listing_url
    products_payload = [dict(product) for product in products]

    missing_providers: list[str] = []
    if not printify_credentials:
        missing_providers.append(OAuthProvider.PRINTIFY.value)
    if not etsy_credentials:
        missing_providers.append(OAuthProvider.ETSY.value)

    response = {
        "listing_url": listing_url,
        "listing": listing,
        "events": events,
        "products": products_payload,
        "ideas": ideas,
        "trends": trends,
        "auth": {
            "user_id": user_id,
            "printify_linked": bool(printify_credentials),
            "etsy_linked": bool(etsy_credentials),
            "missing": missing_providers,
        },
    }
    return response

@app.post("/api/bulk_create", response_model=BulkCreateResponse)
async def bulk_create(request: Request):
    return await bulk_create_handler(request)

@app.get("/trends")
async def list_trends(category: str | None = None):
    return await fetch_trends(category)

@app.get("/events/{month}")
async def list_events(month: str):
    month_key = (month or datetime.utcnow().strftime("%B")).lower()
    events = EVENTS.get(month_key, [])
    return {"month": month_key.capitalize(), "events": events}

@app.get("/product-categories")
async def product_categories(category: str | None = None):
    return get_trending_categories(category)

@app.get("/design-ideas")
async def design_ideas(category: str | None = None):
    return get_design_ideas(category)

@app.get("/product-suggestions")
async def product_suggestions(category: str | None = None, design: str | None = None):
    return get_product_suggestions(category, design)

@app.get("/api/trends/live")
async def live_trends(category: str | None = None):
    return await get_live_trends(category)

@app.post("/api/trends/refresh")
async def refresh_trends_endpoint():
    await refresh_trends()
    return {"status": "ok"}
